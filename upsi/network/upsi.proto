syntax = "proto2";

package upsi;

import "upsi/crypto/elgamal.proto";

// the basic interface
service UPSIRpc {
    rpc Handle(ClientMessage) returns (ServerMessage) {}
}


/*
 * PROTOCOL DATA TYPES
 */
message EncryptedElement {
    oneof element_type {
        NoPayload no_payload = 1;
        PaillierPayload paillier = 2;
        ElGamalPayload elgamal = 3;
        DeletionElement deletion = 4;
        OnlyPaillier only_paillier = 5;
    }

    message NoPayload {
        optional ElGamalCiphertext element = 1;
    }

    message PaillierPayload {
        optional ElGamalCiphertext element = 1;
        optional bytes payload = 2;
    }

    message ElGamalPayload {
        optional ElGamalCiphertext element = 1;
        optional ElGamalCiphertext payload = 2;
    }

    message DeletionElement {
        optional bytes element = 1;
        optional bytes payload = 2;
    }

    message OnlyPaillier {
        optional bytes element = 1;
    }
}

message EncryptedSet {
    repeated EncryptedElement elements = 1;
}

message EncryptedSetVector {
	repeated EncryptedSet elements = 1;
}

message TreeNode {
    repeated EncryptedElement elements = 2;
}

message TreeUpdates {
    repeated bytes hashes = 1;
    repeated TreeNode nodes = 2;
}

message PaillierCiphertext {
    optional bytes ciphertext = 1;
}

// FOR WRITING TREES INTO FILES
message PlaintextElement {
    optional bytes element = 1;
    optional bytes payload = 2;
}

// node size is needed here because plaintext nodes won't always be
// padded to the maximum (unlike the ciphertext nodes)
message PlaintextNode {
    repeated PlaintextElement elements = 1;
    optional int32 node_size = 2;
}

message PlaintextTree {
    repeated PlaintextNode nodes = 1;
    optional int32 stash_size = 2;
    optional int32 node_size = 3;
    optional int32 actual_size = 4;
    optional int32 depth = 5;
}

message EncryptedTree {
    repeated TreeNode nodes = 1;
    optional int32 stash_size = 2;
    optional int32 node_size = 3;
    optional int32 actual_size = 4;
    optional int32 depth = 5;
}

message OPRF_KV {
    optional bytes element = 1;
    optional bytes output = 2;
}

message OPRF {
    repeated OPRF_KV kv = 1;
}

// FOR THE Tree PSI PROTOCOL
message TreeMessage {
    oneof message_content {
        MessageI message_i = 1;
        MessageII message_ii = 2;
    }

    message MessageI {
        optional bytes element = 1;
        // optional TreeUpdates updates = 1;
        // repeated bytes ciphertexts = 2;
    }

    message MessageII {
        optional bytes element = 1;
        // optional ElGamalCiphertext alpha = 1;
        // repeated EncryptedSet candidates = 2;
    }

}


message ClientMessage {
    oneof client_message_oneof {
        TreeMessage tree_msg = 1;
    }
}

// PARTY ONE

message ServerMessage {
    oneof server_message_oneof {
        TreeMessage tree_msg = 1;
    }
}